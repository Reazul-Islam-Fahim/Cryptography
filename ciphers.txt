Additive Cipher

#This is a python program for Additive Cipher
def encrypt(message, key):
    #result is the final encrypted message
    result = ""
    #Run a loop for each character of the plaintext
    for i in range(len(message)):
        char = message[i]

        if (char.isupper()):
            #The formula is : (plaintext character + key) mod 26
            result += chr((ord(char) + key - 65) % 26 + 65)
        elif (char.islower()):
            #We need to subtract 32 for showing the ciphertext in capital letter
            result += chr((ord(char) + key - 97) % 26 + 97)
        else: #if the plaintext character contains the space character
            result += char

    return result

def decrypt(message, key):
    #result is the final encrypted message
    result = ""
    #Run a loop for each character of the plaintext
    for i in range(len(message)):
        char = message[i]

        if (char.isupper()):
            result += chr((ord(char) - key - 65) % 26 + 65)
        elif (char.islower()):
            result += chr((ord(char) - key - 97) % 26 + 97)
        else: #if the plaintext character contains the space character
            result += char

    return result



def main():
    plainText = input("Enter the plaintext: ")
    key = int(input("Enter the shift key value: "))
    cipherText = encrypt(plainText, key)
    # print(f"The encrypted message is : ", end="")
    # for letter in cipherText:
    #     # We need to subtract 32 for showing the ciphertext in capital letter
    #     ch = cipherText[letter]
    #     char = chr(ord(ch) - 32)
    #     print(char, end="")
    print(f"The encrypted message is: {cipherText}")
    decryptedPlaintext = decrypt(cipherText, key)
    print(f"The decrypted message is : {decryptedPlaintext}")

if __name__ == "__main__":
    main()







Multiplicative Cipher

#This is a python program for Multiplicative cipher
import math
def encrypt(message, key):
    #result is the final encrypted message
    result = ""
    #Run a loop for each character of the plaintext
    for i in range(len(message)):
        char = message[i]

        if (char.isupper()):
            #The formula is : (plaintext character * key) mod 26
            result += chr(((ord(char) - 65) * key) % 26 + 65)
        elif (char.islower()):
            #We need to subtract 32 for showing the ciphertext in capital letter
            result += chr(((ord(char) - 97) * key) % 26 + 97)
        else: #if the plaintext character contains the space character
            result += char

    return result

def decrypt(message, key):
    #result is the final encrypted message
    result = ""
    #Run a loop for each character of the plaintext
    for i in range(len(message)):
        char = message[i]

        if (char.isupper()):
            # The formula is : (ciphertext character * modInverse of key modulo 26)) mod 26
            mi = modInverse(26,key)
            if not mi is None:
                result += chr(((ord(char) - 65) * mi) % 26 + 65)
            else:
                print(f"Sorry!!!The multiplicative inverse of {key} modulo 26 does not exits. Can't decrypt the message!")
                return None
            # result += chr(((ord(char) - 65) * mi) % 26 + 65)
        elif (char.islower()):
            #result += chr((ord(char) * mi - 97) % 26 + 97)
            mi = modInverse(26,key)
            if not mi is None:
                result += chr(((ord(char)- 97) * mi) % 26 + 97)
            else:
                print(f"Sorry!!!The multiplicative inverse of {key} modulo 26 does not exits. Can't decrypt the message!")
                return None
            # result += chr(((ord(char) - 97) * mi) % 26 + 97)
        else: #if the plaintext character contains the space character just concatenate it
            result += char

    return result

def modInverse(r1, r2):
    t1, t2 = 0, 1
    while(r2 > 0):
        q = math.floor(r1 / r2)
        r = r1 - q * r2
        #Adjusting the value of r1 and r2
        r1 = r2
        r2 = r
        t = t1 - q * t2
        t1 = t2
        t2 = t

    # print(f"The r1 value : {r1}")
    if(r1 == 1):
        #The multiplicative inverse exists
        return t1
    else:
        return None
def main():
    plainText = input("Enter the plaintext: ")
    key = int(input("Enter the shift key value: "))
    cipherText = encrypt(plainText, key)
    # print(f"The encrypted message is : ", end="")
    # for letter in cipherText:
    #     # We need to subtract 32 for showing the ciphertext in capital letter
    #     ch = cipherText[letter]
    #     char = chr(ord(ch) - 32)
    #     print(char, end="")
    print(f"The encrypted message is: {cipherText}")
    decryptedPlaintext = decrypt(cipherText, key)
    print(f"The decrypted message is : {decryptedPlaintext}")

if __name__ == "__main__":
    main()






Affine Cipher

#This is a python program for Affine Cipher
import math
def encrypt(message, key1, key2):
    #result is the final encrypted message
    result = ""
    finalResult = ""
    #Run a loop for each character of the plaintext
    for i in range(len(message)):
        char = message[i]

        if (char.isupper()):
            #The formula is : T = (P * K1) mod 26
            #                 C = (T + K2) mod 26
            # mi = modInverse(26,key1)
            result = chr(((ord(char) - 65) * key1) % 26 + 65)
            #Then perform the additive cipher on the previous result
            result = chr((ord(result) + key2 - 65) % 26 + 65)
            #Add the resulting character with the finalResult
            finalResult += result


        elif (char.islower()):
            result = chr(((ord(char) - 97) * key1) % 26 + 97)
            #Then perform the additive cipher on the previous result
            result = chr((ord(result) + key2 - 97) % 26 + 97)
            finalResult += result
        else: #if the plaintext character contains the space character
            finalResult += char

    return finalResult

def decrypt(message, key1, key2):
    #result is the final encrypted message
    result = ""
    finalResult = ""
    #Run a loop for each character of the plaintext
    for i in range(len(message)):
        char = message[i]

        if char.isupper():
            #The formula is : T = (C - K2) mod 26
            #                 P = (T * K1 inverse) mod 26
            # mi = modInverse(26, key1)
            mi = pow(key1, -1, 26)
            if not mi is None:
                # Add the additive inverse cipher to the ciphertext
                result = chr((ord(char) - key2 - 65) % 26 + 65)
                # Then multiply the multiplicative inverse with the previous result
                result = chr(((ord(result) - 65) * mi) % 26 + 65)
                finalResult += result
            else:
                print(
                    f"Sorry!!!The multiplicative inverse of {key1} modulo 26 does not exits. Can't decrypt the message!")
                return None
        elif char.islower():
            # mi = modInverse(26, key1)
            mi = pow(key1, -1, 26)
            if not mi is None:
                #Add the additive inverse cipher to the ciphertext
                result = chr((ord(char) - key2 - 97) % 26 + 97)
                #Then multiply the multiplicative inverse with the previous result
                result = chr(((ord(result) - 97) * mi) % 26 + 97)
                finalResult += result
            else:
                print(f"Sorry!!!The multiplicative inverse of {key1} modulo 26 does not exits. Can't decrypt the message!")
                return None
        else: #if the plaintext character contains the space character
            finalResult += char

    return finalResult

def modInverse(r1, r2):
    t1, t2 = 0, 1
    while(r2 > 0):
        q = math.floor(r1 / r2)
        r = r1 - q * r2
        #Adjusting the value of r1 and r2
        r1 = r2
        r2 = r
        t = t1 - q * t2
        t1 = t2
        t2 = t

    # print(f"The r1 value : {r1}")
    if(r1 == 1):
        #The multiplicative inverse exists
        if t1 < 0:
            while t1 < 0:
                t1 += 26
                return t1
        else:
            return t1
        # return t1
    else:
        return None

def main():
    plainText = ''
    #Take the file input
    with open("AffineInput.txt", "r") as rf:
        with open("secretkey.txt", "r") as rf2:

            with open("Encrypted.txt", "w") as wf:
                for letter in rf:
                    plainText += letter

                Keys = rf2.readline().split(" ")
                # print(Keys)
                key1 = Keys[0]
                key2 = Keys[1]
                key1 = int(key1)
                key2 = int(key2)
                # print(type(key1))
                # print(key1, end='')
                # print(key2, end='')
                print(plainText)

                # plainText = plainText[:len(plainText)-1]
                # print(plainText, end='')
                # print(key1)
                # print(key2)
                cipherText = encrypt(plainText, key1, key2)
                # cipher = ''
                # for letter in cipherText:
                #     cipher += letter.upper()
                wf.write("The encrypted message is: "+cipherText.upper())
                #We need to position the file pointer to the begining of the file Encrypted.txt
                # with open("Encrypted.txt", "r") as rf2:
                    #rf2.seek(0) #We need to position the file pointer to the begining of the file Encrypted.txt
                with open("Decrypted.txt", "w") as wf2:
                        # cipherText = rf2.readline()
                        # print(cipherText)
                    decryptedPlaintext = decrypt(cipherText, key1, key2)
                    wf2.write(f"The decrypted message is : {decryptedPlaintext}")

if __name__ == "__main__":
    main()








Autokey cipher

#This program will encrypt the message using autokey cipher
#Fuction for generating the keystream
def generateKeyStream(plainText, key):
    result = key
    for i in range(len(plainText) - 1):
        result += plainText[i]
    return result

#Encryption function
def encrypt(message, key):
    result = ""
    for i in range(len(message)):
        messageChar = message[i]
        keyStreamChar = key[i]
        #Main formula: cipherText = (plainText + keyStream) mod 26
        if messageChar.isupper():
            result += chr(((ord(messageChar) - 65) + (ord(keyStreamChar) - 65)) % 26 + 65)
        elif messageChar.islower():
            result += chr(((ord(messageChar) - 97) + (ord(keyStreamChar) - 97)) % 26 + 97)
        else: ##If we have space as character, then just concatenate it
            result += messageChar

    return result

#Decryption function
def decrypt(message, key):
    result = ""
    for i in range(len(message)):
        messageChar = message[i]
        keyStreamChar = key[i]
        # Main formula: plainText = (cipherText - keyStream) mod 26
        if messageChar.isupper():
            result += chr(((ord(messageChar) - 65) - (ord(keyStreamChar) - 65)) % 26 + 65)
        elif messageChar.islower():
            result += chr(((ord(messageChar) - 97) - (ord(keyStreamChar) - 97)) % 26 + 97)
        else: ##If we have space as character, then just concatenate it
            result += messageChar

    return result

def main():
    plainText = input("Enter the plainText: ")
    autoKey = input("Enter the autoKey: ")
    keyStream = generateKeyStream(plainText, autoKey)
    #Printing the keyStream
    print(f"Key Stream : {keyStream}")
    ciphertext = encrypt(plainText, keyStream)
    print(f"Encrypted ciphertext: {ciphertext}")
    decryptedPlainText = decrypt(ciphertext, keyStream)
    print(f"Decrypted PlainText: {decryptedPlainText}")

if __name__ == "__main__":
    main()





Playfair cipher

# Python program to implement Playfair Cipher

# Function to convert the string to lowercase
def toLowerCase(text):
    return text.lower()

# Function to remove all spaces in a string
def removeSpaces(text):
    newText = ""
    for i in text:
        if i == " ":
            continue
        else:
            newText = newText + i
    return newText

# Function to group 2 elements of a string
# as a list element
def Diagraph(text):
    Diagraph = []
    group = 0
    for i in range(2, len(text), 2):
        Diagraph.append(text[group:i])

        group = i
    Diagraph.append(text[group:])
    return Diagraph

# Function to fill a letter in a string element
# If 2 letters in the same string matches
def FillerLetter(text):
    k = len(text)
    if k % 2 == 0:
        for i in range(0, k, 2):
            if text[i] == text[i+1]:
                new_word = text[0:i+1] + str('x') + text[i+1:]
                new_word = FillerLetter(new_word)
                break
            else:
                new_word = text
    else:
        for i in range(0, k-1, 2):
            if text[i] == text[i+1]:
                new_word = text[0:i+1] + str('x') + text[i+1:]
                new_word = FillerLetter(new_word)
                break
            else:
                new_word = text
    return new_word


list1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

# Function to generate the 5x5 key square matrix
def generateKeyTable(word, list1):
    key_letters = []
    for i in word:
        if i not in key_letters:
            key_letters.append(i)

    compElements = []
    for i in key_letters:
        if i not in compElements:
            compElements.append(i)
    for i in list1:
        if i not in compElements:
            compElements.append(i)

    matrix = []
    while compElements != []:
        matrix.append(compElements[:5])
        compElements = compElements[5:]

    return matrix


def search(mat, element):
    for i in range(5):
        for j in range(5):
            if(mat[i][j] == element):
                return i, j


def encrypt_RowRule(matr, e1r, e1c, e2r, e2c):
    char1 = ''
    if e1c == 4:
        char1 = matr[e1r][0]
    else:
        char1 = matr[e1r][e1c+1]

    char2 = ''
    if e2c == 4:
        char2 = matr[e2r][0]
    else:
        char2 = matr[e2r][e2c+1]

    return char1, char2


def encrypt_ColumnRule(matr, e1r, e1c, e2r, e2c):
    char1 = ''
    if e1r == 4:
        char1 = matr[0][e1c]
    else:
        char1 = matr[e1r+1][e1c]

    char2 = ''
    if e2r == 4:
        char2 = matr[0][e2c]
    else:
        char2 = matr[e2r+1][e2c]

    return char1, char2

def decrypt_RowRule(matr, e1r, e1c, e2r, e2c):
    char1 = ''
    if e1c == 0:
        char1 = matr[e1r][4]
    else:
        char1 = matr[e1r][e1c-1]

    char2 = ''
    if e2c == 0:
        char2 = matr[e2r][4]
    else:
        char2 = matr[e2r][e2c-1]

    return char1, char2

def decrypt_ColumnRule(matr, e1r, e1c, e2r, e2c):
    char1 = ''
    if e1r == 0:
        char1 = matr[4][e1c]
    else:
        char1 = matr[e1r-1][e1c]

    char2 = ''
    if e2r == 0:
        char2 = matr[4][e2c]
    else:
        char2 = matr[e2r-1][e2c]

    return char1, char2

def encryptdecrypt_RectangleRule(matr, e1r, e1c, e2r, e2c):
    char1 = ''
    char1 = matr[e1r][e2c]

    char2 = ''
    char2 = matr[e2r][e1c]

    return char1, char2


def encryptByPlayfairCipher(Matrix, plainList):
    CipherText = []
    for i in range(0, len(plainList)):
        c1 = 0
        c2 = 0
        ele1_x, ele1_y = search(Matrix, plainList[i][0])
        ele2_x, ele2_y = search(Matrix, plainList[i][1])

        if ele1_x == ele2_x:
            c1, c2 = encrypt_RowRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)
            # Get 2 letter cipherText
        elif ele1_y == ele2_y:
            c1, c2 = encrypt_ColumnRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)
        else:
            c1, c2 = encryptdecrypt_RectangleRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)

        cipher = c1 + c2
        CipherText.append(cipher)
    return CipherText

def decryptByPlayfairCipher(Matrix, cipherList):
    decryptedPlainText = []
    for i in range(0, len(cipherList)):
        c1 = 0
        c2 = 0
        ele1_x, ele1_y = search(Matrix, cipherList[i][0])
        ele2_x, ele2_y = search(Matrix, cipherList[i][1])

        if ele1_x == ele2_x:
            c1, c2 = decrypt_RowRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)
            # Get 2 letter cipherText
        elif ele1_y == ele2_y:
            c1, c2 = decrypt_ColumnRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)
        else:
            c1, c2 = encryptdecrypt_RectangleRule(Matrix, ele1_x, ele1_y, ele2_x, ele2_y)

        plain = c1 + c2
        decryptedPlainText.append(plain)
    return decryptedPlainText

def main():
    #text_Plain = 'instruments'
    text_Plain = input("Enter the plaintext: ")
    text_Plain = removeSpaces(toLowerCase(text_Plain))
    PlainTextList = Diagraph(FillerLetter(text_Plain))
    if len(PlainTextList[-1]) != 2:
        # PlainTextList[-1] = PlainTextList[-1]+'z'
        PlainTextList[-1] = PlainTextList[-1] + 'x'

    # key = "Monarchy"
    key = input("Enter the keyword: ")
    print("Key text:", key)
    key = toLowerCase(key)
    Matrix = generateKeyTable(key, list1)

    #Printing the secret key table
    print("---------------------")
    print("  SECRET KEY MATRIX  ")
    print("---------------------")
    for row in range(len(Matrix)):
        for cols in range(len(Matrix[row])):
            print(f"{Matrix[row][cols]:>2}", end="  ")
        print()
    print("---------------------")



    print("Plain Text:", text_Plain)
    print("Printing the plainTextList below")
    print(f"Digraph: ")
    for i in PlainTextList:
        print(f"{i:4}", end="")
    CipherList = encryptByPlayfairCipher(Matrix, PlainTextList)
    print()
    CipherText = ""
    for i in CipherList:
        CipherText += i
    print("CipherText:", CipherText)

    decryptedPlainList = decryptByPlayfairCipher(Matrix, CipherList)

    decryptedPlainTextWithBogus = ""
    for i in decryptedPlainList:
        decryptedPlainTextWithBogus += i
    print("Decrypted PlainText with bogus letter:", decryptedPlainTextWithBogus)
    decryptedPlaintext = ''
    for letter in decryptedPlainTextWithBogus:
        if letter != 'x':
            decryptedPlaintext += letter
            
    print(f"Decrypted PlainText without bogus letter: {decryptedPlaintext}")
if __name__ == "__main__":
    main()








Hill cipher

pip install egcd

"""
Implementation of Hill Cipher!

Important notation:
K = Matrix which is our 'Secret Key'
P = Vector of plaintext (that has been mapped to numbers)
C = Vector of Ciphered text (in numbers)

C = E(K,P) = K*P (mod X) -- X is length of alphabet used
P = D(K,C) = inv(K)*C (mod X)  -- X is length of alphabet used

"""

import numpy as np
from egcd import egcd  # pip install egcd

alphabet = "abcdefghijklmnopqrstuvwxyz "

letter_to_index = dict(zip(alphabet, range(len(alphabet))))
index_to_letter = dict(zip(range(len(alphabet)), alphabet))


def matrix_mod_inv(matrix, modulus):
    """We find the matrix modulus inverse by
    Step 1) Find determinant
    Step 2) Find determinant value in a specific modulus (usually length of alphabet)
    Step 3) Take that det_inv times the det*inverted matrix (this will then be the adjoint) in mod 26
    """
    #Here we calculate the determinant of matrix via np.linalg.det(matrix), since this method calculate the
    #result numerically, we need to round off the result to avoid round-off error
    det = int(np.round(np.linalg.det(matrix)))  # Step 1)
    #Here we calculate the determinant inverse modulo 26 via extended Euclidean Algorithm
    det_inv = egcd(det, modulus)[1] % modulus  # Step 2)
    #Adjoint matrix = determinant * (inverse of matrix)
    #Matrix modulo inverse(K^-1) = determinantInverse * Adjoint matrix
    matrix_modulus_inv = (det_inv * np.round(det * np.linalg.inv(matrix)).astype(int) % modulus )  # Step 3)

    return matrix_modulus_inv


def encrypt(message, K):
    encrypted = ""
    message_in_numbers = []

    for letter in message:
        #Convert each character of the message to equivalent ascii value
        message_in_numbers.append(letter_to_index[letter])

    #Here we split the numerical message list into blocks of matrix of size m
    split_P = [message_in_numbers[i : i + int(K.shape[0])] for i in range(0, len(message_in_numbers), int(K.shape[0]))]

    for P in split_P:
        #np.asarray(P) returns a row vector, we need to convert it to column vector via np.transpose() method
        #to be able to multiply it with the key matrix
        P = np.transpose(np.asarray(P))[:, np.newaxis]

        #To create m-size blocks, we need to add bogus letter, if
        #P.shape[0] = 1 but K.shape[0] = 2, we need to add one extra bogus letter
        while P.shape[0] != K.shape[0]:
            P = np.append(P, letter_to_index[" "])[:, np.newaxis]

        #np.dot(K, P) % len(alphabet) performs the multiplication (K * P) mod 27
        numbers = np.dot(K, P) % len(alphabet)
        #The result of the multiplication is a column vector of size 3 by 1
        n = numbers.shape[0]  # length of encrypted message (in numbers)

        # Map back to get encrypted text
        for idx in range(n):
            #here we add each row value of the column vector numbers
            #we do the followings: numbers[0][0] + numbers[1][0] + numbers[2][0] for column vector of size 3 by 1
            number = int(numbers[idx, 0])
            encrypted += index_to_letter[number]

    return encrypted


def decrypt(cipher, Kinv):
    decrypted = ""
    cipher_in_numbers = []

    for letter in cipher:
        cipher_in_numbers.append(letter_to_index[letter])

    split_C = [cipher_in_numbers[i : i + int(Kinv.shape[0])] for i in range(0, len(cipher_in_numbers), int(Kinv.shape[0]))]

    for C in split_C:
        C = np.transpose(np.asarray(C))[:, np.newaxis]
        #the formula is: (P = (K^-1 * C) mod 26)
        numbers = np.dot(Kinv, C) % len(alphabet)
        n = numbers.shape[0]

        for idx in range(n):
            number = int(numbers[idx, 0])
            decrypted += index_to_letter[number]
            
    return decrypted

def main():
    # message = 'my life is potato'
    #message = "help"
    message = input("Enter the plaintext: ")

    #K = np.matrix([[3, 3], [2, 5]])
    #K = np.matrix([[6, 24, 1], [13,16,10], [20,17,15]]) # for length of alphabet = 26
    K = np.matrix([[3,10,20],[20,19,17], [23,78,17]]) # for length of alphabet = 27
    Kinv = matrix_mod_inv(K, len(alphabet))

    encrypted_message = encrypt(message, K)
    decrypted_message = decrypt(encrypted_message, Kinv)

    print("Original message: " + message)
    print("Encrypted message: " + encrypted_message)
    print("Decrypted message: " + decrypted_message)


main()











Vegenere cipher

# Python code to implement
# Vigenere Cipher

# This function generates the
# key in a cyclic manner until
# it's length isn't equal to
# the length of original text
def generateKey(string, key):
    key = list(key)
    if len(string) == len(key):
        return key
    else:
        for i in range(len(string) -
                       len(key)):
            key.append(key[i % len(key)])
    return "".join(key)


# This function returns the
# encrypted text generated
# with the help of the key
def cipherText(string, key):
    cipher_text = []
    for i in range(len(string)):
        x = (ord(string[i]) +
             ord(key[i])) % 26
        x += ord('A')
        cipher_text.append(chr(x))
    return "".join(cipher_text)


# This function decrypts the
# encrypted text and returns
# the original text
def originalText(cipher_text, key):
    orig_text = []
    for i in range(len(cipher_text)):
        #When subtracting ord('C') - ord('Y') = 2 - 24 = -22
        #That's why we need to add 26 with -22 to get 4
        x = (ord(cipher_text[i]) -
             ord(key[i]) + 26) % 26
        x += ord('A')
        orig_text.append(chr(x))
    return "".join(orig_text)


# Driver code
if __name__ == "__main__":
    # string = "GEEKSFORGEEKS"
    # keyword = "AYUSH"
    string = input("Enter the string: ")
    keyword = input("Enter the keyword: ")
    key = generateKey(string, keyword)
    cipher_text = cipherText(string, key)
    print("Ciphertext :", cipher_text)
    print("Original/Decrypted Text :",
          originalText(cipher_text, key))












DES

# Python3 code for the above approach

# Hexadecimal to binary conversion
def hex2bin(s):
    mp = {'0': "0000",
          '1': "0001",
          '2': "0010",
          '3': "0011",
          '4': "0100",
          '5': "0101",
          '6': "0110",
          '7': "0111",
          '8': "1000",
          '9': "1001",
          'A': "1010",
          'B': "1011",
          'C': "1100",
          'D': "1101",
          'E': "1110",
          'F': "1111"}
    bin = ""
    for i in range(len(s)):
        bin = bin + mp[s[i]]
    return bin


# Binary to hexadecimal conversion
def bin2hex(s):
    mp = {"0000": '0',
          "0001": '1',
          "0010": '2',
          "0011": '3',
          "0100": '4',
          "0101": '5',
          "0110": '6',
          "0111": '7',
          "1000": '8',
          "1001": '9',
          "1010": 'A',
          "1011": 'B',
          "1100": 'C',
          "1101": 'D',
          "1110": 'E',
          "1111": 'F'}
    hex = ""
    for i in range(0, len(s), 4):
        ch = ""
        ch = ch + s[i]
        ch = ch + s[i + 1]
        ch = ch + s[i + 2]
        ch = ch + s[i + 3]
        hex = hex + mp[ch]

    return hex


# Binary to decimal conversion
def bin2dec(binary):
    binary1 = binary
    decimal, i, n = 0, 0, 0
    while (binary != 0):
        dec = binary % 10
        decimal = decimal + dec * pow(2, i)
        binary = binary // 10
        i += 1
    return decimal


# Decimal to binary conversion
def dec2bin(num):
    # If the decimal number is from 8 to 15, then res holds the 4-digit binary representation of the decimal number
    res = bin(num).replace("0b", "")
    # If the length of the digit is less than 4 implying 1-digit, 2-digit or 3-digit
    # binary number, then we have to add appropiate number of 0s at the end
    # to make it 4 digit. For example, for 1-digit number(decimal 0, 1), we have to append
    # 3 extra 0s at the end, for 2-digit number(decimal number from 2 to 3), we have to
    # append 2 extra 0s at the end.And for 3-digit binary number(decimal number ranging
    # from 4 to 7), we have to pad 1 extra 0 to make it a 4-digit binary number.
    # The below if portion does this thing, the variable "counter" denote how many zeroes
    # have to added at the end.
    if (len(res) % 4 != 0):
        div = len(res) / 4  # For 1-digit, div = 0.25, For 2-digit, div = 0.5 and for 3-digit, div = 0.75
        div = int(div)  # For all the above cases, the div is 0 when taking interger portion only
        counter = (4 * (div + 1)) - len(res)  # For 1-digit, counter = (4*1) - 1 = 3
        # For 2-digit, counter = (4*1) - 2 = 2
        # For 3-digit, counter = (4*1) - 3 = 1
        for i in range(0, counter):
            # This for loop appends appropiate number of 0's at the end
            res = '0' + res
    return res


# Permute function to rearrange the bits
def permute(k, arr, n):
    permutation = ""
    for i in range(0, n):
        permutation = permutation + k[arr[i] - 1]
    return permutation


# shifting the bits towards left by nth shifts
def shift_left(k, nth_shifts):
    s = ""
    for i in range(nth_shifts):
        for j in range(1, len(k)):
            s = s + k[j]  # Creating a string s from key's index position 1 to index position len(key) - 1
        s = s + k[0]  # At last, add the k[0] value at the last(because of circular left shift)
        k = s  # Assign s string to K for next shift in the next iteration(Think of left circular shift of 2!!!)
        s = ""
    return k


# calculating xow of two strings of binary number a and b
def xor(a, b):
    ans = ""
    for i in range(len(a)):
        if a[i] == b[i]:
            ans = ans + "0"
        else:
            ans = ans + "1"
    return ans


# Table of Position of 64 bits at initial level: Initial Permutation Table
initial_perm = [58, 50, 42, 34, 26, 18, 10, 2,
                60, 52, 44, 36, 28, 20, 12, 4,
                62, 54, 46, 38, 30, 22, 14, 6,
                64, 56, 48, 40, 32, 24, 16, 8,
                57, 49, 41, 33, 25, 17, 9, 1,
                59, 51, 43, 35, 27, 19, 11, 3,
                61, 53, 45, 37, 29, 21, 13, 5,
                63, 55, 47, 39, 31, 23, 15, 7]

# Expansion D-box Table
exp_d = [32, 1, 2, 3, 4, 5, 4, 5,
         6, 7, 8, 9, 8, 9, 10, 11,
         12, 13, 12, 13, 14, 15, 16, 17,
         16, 17, 18, 19, 20, 21, 20, 21,
         22, 23, 24, 25, 24, 25, 26, 27,
         28, 29, 28, 29, 30, 31, 32, 1]

# Straight Permutation Table
per = [16, 7, 20, 21,
       29, 12, 28, 17,
       1, 15, 23, 26,
       5, 18, 31, 10,
       2, 8, 24, 14,
       32, 27, 3, 9,
       19, 13, 30, 6,
       22, 11, 4, 25]

# S-box Table
sbox = [[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],

        [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],

        [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],

        [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],

        [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],

        [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],

        [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],

        [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]]

# Final Permutation Table
final_perm = [40, 8, 48, 16, 56, 24, 64, 32,
              39, 7, 47, 15, 55, 23, 63, 31,
              38, 6, 46, 14, 54, 22, 62, 30,
              37, 5, 45, 13, 53, 21, 61, 29,
              36, 4, 44, 12, 52, 20, 60, 28,
              35, 3, 43, 11, 51, 19, 59, 27,
              34, 2, 42, 10, 50, 18, 58, 26,
              33, 1, 41, 9, 49, 17, 57, 25]


# pt --> Plaintext is in hexadecimal
# rkb --> Round Keys is in binary
# rk --> Round keys is in hexadecimal
def encrypt(pt, rkb, rk):
    pt = hex2bin(pt)

    # Initial Permutation
    pt = permute(pt, initial_perm, 64)
    print("After initial permutation", bin2hex(pt))

    # Splitting
    left = pt[0:32]
    right = pt[32:64]
    # This for loop acts as the function f of the Feistal Cipher at each round
    for i in range(0, 16):
        # Expansion D-box: Expanding the 32 bits data into 48 bits
        right_expanded = permute(right, exp_d, 48)

        # XOR RoundKey[i] and right_expanded
        xor_x = xor(right_expanded, rkb[i])

        # S-boxex: substituting the value from s-box table by calculating row and column
        sbox_str = ""
        # This for loop runs for 8 times for S-Box 1 to S-Box 8
        for j in range(0, 8):
            row = bin2dec(int(xor_x[j * 6] + xor_x[j * 6 + 5]))
            col = bin2dec(
                int(xor_x[j * 6 + 1] + xor_x[j * 6 + 2] + xor_x[j * 6 + 3] + xor_x[j * 6 + 4]))
            val = sbox[j][row][col]
            sbox_str = sbox_str + dec2bin(val)

        # Straight D-box: After substituting rearranging the bits
        sbox_str = permute(sbox_str, per, 32)

        # XOR left and sbox_str
        result = xor(left, sbox_str)
        left = result

        # Swapper
        if (i != 15):  # At round 16, we do not swap, that's why this condition checking
            left, right = right, left
        print("Round ", i + 1, " ", bin2hex(left),
              " ", bin2hex(right), " ", rk[i])

    # Combination
    combine = left + right

    # Final permutation: final rearranging of bits to get cipher text
    cipher_text = permute(combine, final_perm, 64)
    return cipher_text


pt = "123456ABCD132536"
key = "AABB09182736CCDD"

# Key generation
# --hex to binary
key = hex2bin(key)

# --parity bit drop table
keyp = [57, 49, 41, 33, 25, 17, 9,
        1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27,
        19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7, 62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29,
        21, 13, 5, 28, 20, 12, 4]

# getting 56 bit key from 64 bit using the parity bits
key = permute(key, keyp, 56)

# Number of bit shifts
shift_table = [1, 1, 2, 2,
               2, 2, 2, 2,
               1, 2, 2, 2,
               2, 2, 2, 1]

# Key- Compression Table : Compression of key from 56 bits to 48 bits
key_comp = [14, 17, 11, 24, 1, 5,
            3, 28, 15, 6, 21, 10,
            23, 19, 12, 4, 26, 8,
            16, 7, 27, 20, 13, 2,
            41, 52, 31, 37, 47, 55,
            30, 40, 51, 45, 33, 48,
            44, 49, 39, 56, 34, 53,
            46, 42, 50, 36, 29, 32]

# Splitting
left = key[0:28]
right = key[28:56]

rkb = []  # rkb for RoundKeys in binary
rk = []  # rk for RoundKeys in hexadecimal
# This for loop generate keys for each of the 16 rounds
for i in range(0, 16):
    # Shifting the bits by nth shifts by checking from shift table
    left = shift_left(left, shift_table[
        i])  # At every iteration, left and right part of the key will be the shifted left and right part of the key in the previous round
    right = shift_left(right, shift_table[i])

    # Combination of left and right string
    combine_str = left + right

    # Compression of key from 56 to 48 bits
    round_key = permute(combine_str, key_comp, 48)

    rkb.append(round_key)
    rk.append(bin2hex(round_key))

print("Encryption")
cipher_text = bin2hex(encrypt(pt, rkb, rk))
print("Cipher Text : ", cipher_text)

print("Decryption")
rkb_rev = rkb[::-1]
rk_rev = rk[::-1]
text = bin2hex(encrypt(cipher_text, rkb_rev, rk_rev))
print("Plain Text : ", text)












AES

pip install pycryptodome

'''
For this code install pycrytodome first

To do this simply type the following in terminal:
    pip install pycryptodome


'''

from Crypto.Random import get_random_bytes # for key generation
from Crypto.Protocol.KDF import PBKDF2 # for preventing bruteforce attack

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad,unpad


# key generation--> generating 32 bytes key

simple_key = get_random_bytes(32)
print("\n\nThe output that we get:\n"+ str(simple_key))

password = "mypassword"

key = PBKDF2(password, simple_key, dkLen=32)
print("\n\nOur actual key:\n"+str(key))

#----------key generation ends-------------

#Encryption process starts here

message = b"Hello group B. Group B Rocks!!!"
print("\n\nThis is our message after converting it to bytes:\n"+str(message))


cipher = AES.new(key, AES.MODE_CBC)
ciphered_data = cipher.encrypt(pad(message, AES.block_size))

print("\n\nThis is our encrypted data:\n"+ str(ciphered_data))

# sir jodi bole onno file e save koro cipher text ke

with open('encrypted.bin','wb') as f: # bytes data ke binary file e save korbo
    f.write(cipher.iv)
    f.write(ciphered_data)


#------Encryption ends here----------------------

# Decryption process starts here

# sir jodi bole file theke input naw

with open('encrypted.bin','rb') as f: 
    iv = f.read(16)
    ciphered_data = f.read()


cipher = AES.new(key, AES.MODE_CBC,iv)
original_msg = unpad(cipher.decrypt(ciphered_data),AES.block_size)

print("\n\nThe original Message is:\n"+ str(original_msg))

#--------Decryption ends here-----------
print("\n\n\nThe program has ended")









RSA

import math,random

def keyGeneration(p, q):
    # step 2 --> Calculate n = p * q
    n = p * q
    print("n =", n)

    # step 3 --> calculate phi(n) = (p - 1) * (q - 1)
    phi = (p - 1) * (q - 1)

    # step 4 --> select an integer e such that 1 < e < phi(n) and e is coprime to phi(n)
    while True:
        e = random.randint(2, phi)
        print(f"The random integer e: {e}")
        # checking whether e is coprime to phi(n)
        if (math.gcd(e, phi) == 1):
            break
        else:
            print(f"{e} is not coprime to phi({n})={phi}, Try another random integer between 2 and {phi}")

    print("e =", e)
    # step 5 --> Calculate the private key d = e^-1 (mod phi(n))
    d = modInverse(phi, e)
    # d = modInverse(phi, 13)
    print(f"phi({n}) = {phi}")
    print("d =", d)
    print(f'Public key: {e, n}')
    print(f'Private key: {d, n}')

    return e, d, n
    # return 13, d, n

def encrypt(P, e, n):
    # C = pow(P, e)
    # C = math.fmod(C, n)  #CipherText = P^e mod n
    C = mod_power(P, e, n)
    # C = power(C, e, n)
    # C = math.pow(P, e) % n
    return C

def decrypt(C, d, n):
    # decryption
    # M = pow(C, d)
    # Here we need to use fast modular exponentiation algorithm
    # YouTube Video Link: https://www.youtube.com/watch?v=3Bh7ztqBpmw
    # M = math.fmod(M, n) #Plaintext = C^d mod n
    M = mod_power(C, d, n)
    # M = power(M, d, n)
    # M = math.pow(C, d) % n
    return M

def power(x, y, p):
    res = 1  # Initialize result

    # Update x if it is more
    # than or equal to p
    x = x % p

    if (x == 0):
        return 0

    while (y > 0):

        # If y is odd, multiply
        # x with result
        if ((y & 1) == 1):
            res = (res * x) % p

        # y must be even now
        y = y >> 1  # y = y/2
        x = (x * x) % p

    return res

def mod_power(a, n, m):
    r = 1
    while n > 0:
        if n & 1 == 1:
            r = (r * a) % m #Same as product of yi if the corresponding bit value is 1
        a = (a * a) % m #Every time, I advance the bit position further, same as yi + 1 = (yi)^2
        n >>= 1
    return r

def modInverse(r1, r2):
    temp = r1
    t1, t2 = 0, 1
    while (r2 > 0):
        q = math.floor(r1 / r2)
        r = r1 - q * r2
        # Adjusting the value of r1 and r2
        r1 = r2
        r2 = r
        t = t1 - q * t2
        t1 = t2
        t2 = t

    # print(f"The r1 value : {r1}")
    if (r1 == 1):  # If gcd = 1, then multiplicative inverse exists
        # The multiplicative inverse exists
        if t1 < 0:
            while t1 < 0:
                t1 += temp
            return t1
        else:
            return t1
        # return t1
    else:
        return None

def main():
    p = int(input(f"Enter first large prime number p: "))
    q = int(input(f"Enter second large prime number q: "))
    msg = int(input(f"Enter the message(in numerical value): "))
    print(f'Original message:{msg}')
    # This routine creates the public and private key at the receiver side
    e, d, n = keyGeneration(p, q)
    cipherText = encrypt(msg, e, n)
    print(f'Encrypted message: {cipherText}')
    decryptedPlainText = decrypt(cipherText, d, n)
    print(f'Decrypted message: {decryptedPlainText}')

if __name__ == '__main__':
    main()












RSA-Digital-Signature

import math, random

def keyGeneration():
    #Step 1 --> Select two large prime numbers such that p != q
    p = int(input(f"Enter first large prime number p: "))
    while True:
        q = int(input(f"Enter second large prime number q: "))
        if q == p: 
            print(f"Please select a different prime number other than {p}")
        else:
            break
    
    
    # step 2 --> Calculate n = p * q
    n = p * q
    print("n =", n)

    # step 3 --> calculate phi(n) = (p - 1) * (q - 1)
    phi = (p - 1) * (q - 1)

    # step 4 --> select an integer e such that 1 < e < phi(n) and e is coprime to phi(n)
    while True:
        e = random.randint(2, phi-1)
        print(f"The random integer e: {e}")
        # checking whether e is coprime to phi(n)
        if (math.gcd(e, phi) == 1):
            break
        else:
            print(f"{e} is not coprime to phi({n})={phi}, Try another random integer between 2 and {phi-1}")
    # e = 313

    print("e =", e)
    # step 5 --> Calculate the private key d = e^-1 (mod phi(n))
    # d = modInverse(phi, e)
    d = pow(e, -1, phi)  #Calculating the multiplicative inverse of e modulo phi(n)
    print(f"phi({n}) = {phi}")
    print("d =", d)
    print(f'Public key: {e, n}')
    print(f'Private key: {d}')

    return e, d, n
    # return 35535, d, n


def Signing(msg, d, n):
    # S = M^d mod n, here M = Message
    S = mod_power(msg, d, n)
    return S

def mod_power(a, n, m):
    r = 1  #r is the output value or return value
    # y = a % m , here y is y0, since it will be done anyway in line 84, we omit this line And since y is not used any further, we can replace yi with a
    while n > 0:
        if n & 1 == 1:  #Here, we grab every bit b0, b1, b1,..,bt and move them to the LSB position, when bitwise-and with ...0001, All the bits except the LSB bit is 0ed,
            # only the LSB bit is preserved.
            #Then we right shift the n by 1 (line 85) so that the next bit position b1 comes to the LSB position, in this way we traverse the binary digits in reverse order(from b0 to bt), we do this until all the bit values becomes 0 in which case bi becomes 0, and we break out of the while loop
            r = (r * a) % m #Same as product of yi(mod m) if the corresponding bit value is 1
        a = (a * a) % m #same as yi + 1 = (yi)^2 the recurrence relation we established on slide, it needs to be done for every bit position no matter what(bi can be 0 or 1)
        n >>= 1 #Every time, I advance the bit position further
    return r


def Verifying(S, e, n):
    # M' = S^e mod n
    msgPrime = mod_power(S, e, n)
    return msgPrime


def main():
    msg = int(input(f"Enter the message(in numerical value): "))
    print(f'Original message:{msg}')
    # This routine creates the public and private key at the receiver side
    e, d, n = keyGeneration()
    signature = Signing(msg, d, n)
    print(f'Signature is: {signature}')
    msgPrime = Verifying(signature, e, n)
    print(f"Calculated message from the received signature: {msgPrime}")
    # If M' == M, then the signature is verified, otherwise the signature is forgery signature
    if msgPrime != msg:
        print(f"The message signature {signature} is a forgery signature!!!!")
    else:
        print(f'Signature {signature} is verified successfully.')

if __name__ == '__main__':
    main()













Rail Fence cipher

def main():
    print("RailFenceCipher_Demo")

    print()

    clearText = "Hello World!"
    print("Original Text: " + clearText)
    print()

    key = 3 #Key works as the depth of the Rail-Fence Cipher

    cipherText = cipher(clearText, key)
    print("Ciphered Text: {0}".format(cipherText))

    decipherText = decipher(cipherText, key)
    print("Deciphered Text: {0}".format(decipherText))

    return


def cipher(clearText, key):
    result = ""

    matrix = [["" for x in range(len(clearText))] for y in range(key)] # list comprehension --youtube

    increment = 1
    row = 0
    col = 0

    for c in clearText:
        if row + increment < 0 or row + increment >= len(matrix):
            # When the row counter reaches the last row, then increment becomes -1 so that
            # The row counter points to the row before the last in the next iteration.
            # When the row counter reaches first row, the increment becomes 1 so that
            # The row counter points to the row after the first in the next iteration.
            # At every iteration, the column counter will always increment by 1
            increment = increment * -1

        matrix[row][col] = c

        row += increment
        col += 1

    for list in matrix:
        result += "".join(list)  #We convert each list into a string

    return result


def decipher(cipherText, key):
    result = ""

    matrix = [["" for x in range(len(cipherText))] for y in range(key)]

    # Here idx works as the index position of the ciphertext
    idx = 0
    increment = 1

    for selectedRow in range(0, len(matrix)):
        row = 0

        for col in range(0, len(matrix[row])):
            if row + increment < 0 or row + increment >= len(matrix):
                # When the row counter reaches the last row, then increment becomes -1 so that
                # The row counter points to the row before the last in the next iteration.
                # When the row counter reaches first row, the increment becomes 1 so that
                # The row counter points to the row after the first in the next iteration.
                # At every iteration, the column counter will always increment by 1
                increment = increment * -1
            # We traverse the matrix in zig-zag order and in the first iteration of the
            # outer loop, we fill in the ciphertext value in the first row position
            # In the 2nd  iteration of the outer loop, we fill in the ciphertext value in
            # the 2nd row position and so on.

            if row == selectedRow:
                matrix[row][col] += cipherText[idx]
                idx += 1

            row += increment

    matrix = transpose(matrix)   #Instead of transposing, we can traverse in zig-zag way to build the ciphertext
    for list in matrix:
        result += "".join(list)

    return result


def transpose(m):
    # Here m is the cipher matrix of size 3 by 12
    # Here, we create a matrix of size 12 by 3,
    # so len(m[0]) = 12 is the number of rows and
    # len(m) = 3 is the number of columns
    result = [[0 for y in range(len(m))] for x in range(len(m[0]))]
    # Here, in the for loop, we traverse each element of the cipher matrix m
    for i in range(len(m)):
        for j in range(len(m[0])):
            # We transpose the matrix m[i][j], so row i of "m" matrix
            # becomes column "i" of ressult matrix and vice-versa
            result[j][i] = m[i][j]

    return result


main()














Transposition cipher

import copy, math
alphabet = 'abcdefghijklmnopqrstuvwxyz '
# encryptionKey = {3: 1, 1: 2, 4: 3, 5: 4, 2: 5}
decryptionKey = {1: 3, 2: 1, 3: 4, 4: 5, 5: 2}
encryptionKey = [2,0,3,4,1]
decryptionKey = [1,4,0,2,3]
# encryptionKey = [3,2,0,1,4,5,6]
# decryptionKey = [0,1,2,3,4,5,6]
letter_to_index = dict(zip(alphabet, range(len(alphabet))))
index_to_letter = dict(zip(range(len(alphabet)), alphabet))

print(letter_to_index)
print(index_to_letter)
#How to define 2D list in python
# rows, cols = (5, 5)
# arr = [[0 for i in range(cols)] for j in range(rows)]
# print(arr)
def encryption(message, keyword):
    key = int(keyword) #Converting the numeric string into an integer
    splitmessage = [message[i:i+key] for i in range(0, len(message), key)]
    print(f"Spliited Message List: {splitmessage}")
    table = [['z' for i in range(key)] for j in range(len(splitmessage))]
    # print(table)
    #Step1: Entering the message characters in the table row by row.
    for rows in range(len(splitmessage)):
        i = rows
        j = 0
        for cols in range(key):
            if j < len(splitmessage[i]):
                table[rows][cols] = splitmessage[i][j]
                j = j + 1

    print(f"Table after reading row by row : {table}")
    #Take the copy of the table
    copyTable = copy.deepcopy(table)
    # print(table)
    # print(copyTable)
    #Step2 : Reorder the table column according to the encryption key
    # encryptionKey = {3: 1, 1: 2, 4: 3, 5: 4, 2: 5}
    for row in range(len(copyTable)):
        for j in range(len(copyTable[row])):
            copyTable[row][j] = table[row][encryptionKey[j]]

    # print(copyTable)
    print(f"Table after reordering according to the encryption key: {copyTable}")
    # Step3 : Now we read the table column by column
    cipher = ''
    for cols in range(len(copyTable[0])): #cols = 0 to 4
        for rows in range(len(copyTable)): #rows = 0 to 2
            cipher += copyTable[rows][cols]

    print(cipher)
    return cipher, copyTable


def decryption(message, keyword, table):
    key = int(keyword) #Converting the numeric string into an integer
    # splitmessage = [message[i:i+key] for i in range(0, len(message), key)]
    # print(splitmessage)
    #
    # table = [['z' for i in range(key)] for j in range(len(splitmessage))]
    splitmessageforDecrypt = [message[i:i+len(table)] for i in range(0, len(message), len(table))]
    print(splitmessageforDecrypt)
    # columnTable = [[0 for i in range(key)] for j in range(len(splitmessage))]
    columnTable = [[0 for i in range(key)] for j in range(math.ceil(len(message) / key))]

    #Step1: Entering the message characters in the table column by column.
    for cols in range(key): #Key = 5, [0,1,2,3,4]
        i = cols
        j = 0
        for rows in range(len(table)): #len(table) = 4 [0,1,2,3]
            # if j < len(splitmessage[i]):
                columnTable[j][i] = splitmessageforDecrypt[i][j]
                j = j + 1
    print(f"Table after reading column by column : {columnTable}")
    #Step2 : Reorder the matrix according to the decryption key
    #Take the copy of the table
    copyTable = copy.deepcopy(columnTable)
    # print(table)
    # print(copyTable)
    #Step2 : Reorder the table column according to the decryption key
    # encryptionKey = {3: 1, 1: 2, 4: 3, 5: 4, 2: 5}
    for row in range(len(copyTable)):
        for j in range(len(copyTable[row])):
            copyTable[row][j] = columnTable[row][decryptionKey[j]]

    print(f"Table after reordering according to the decryption key: {copyTable}")

    #Step 3: read the table row by row
    decryptedPlainText = ''
    for rows in range(len(copyTable)):
        for cols in range(len(copyTable[rows])):
            decryptedPlainText += copyTable[rows][cols]

    # print(decryptedPlainText)
    return decryptedPlainText
def main():
    message = input("Enter the plaintext: ")
    key = input("Enter the key(group size or column size): ")

    cipherText, table = encryption(message, key)
    # cipherText = encryption("I am Shafi.", "5")
    print(f"The encrypted ciphertext is: {cipherText.upper()}")
    plaintext = decryption(cipherText, key, table)
    print(f"The decrypted plaintext is: {plaintext.lower()}")


main()














Double Transposition cipher

import copy
import math
alphabet = 'abcdefghijklmnopqrstuvwxyz '
# encryptionKey = {3: 1, 1: 2, 4: 3, 5: 4, 2: 5}
decryptionKey = {1: 3, 2: 1, 3: 4, 4: 5, 5: 2}
encryptionKey = [2,0,3,4,1]
decryptionKey = [1,4,0,2,3]
letter_to_index = dict(zip(alphabet, range(len(alphabet))))
index_to_letter = dict(zip(range(len(alphabet)), alphabet))

print(letter_to_index)
print(index_to_letter)
#How to define 2D list in python
# rows, cols = (5, 5)
# arr = [[0 for i in range(cols)] for j in range(rows)]
# print(arr)
def encryption(message, keyword):
    key = int(keyword) #Converting the numeric string into an integer
    splitmessage = [message[i:i+key] for i in range(0, len(message), key)]
    print(f"Splitted Message List: {splitmessage}")
    table = [['z' for i in range(key)] for j in range(len(splitmessage))]
    # print(table)
    #Step1: Entering the message characters in the table row by row.
    for rows in range(len(splitmessage)):
        i = rows
        j = 0
        for cols in range(key):
            if j < len(splitmessage[i]):
                table[rows][cols] = splitmessage[i][j]
                j = j + 1

    print(f"Table after reading row by row : {table}")
    #Take the copy of the table
    copyTable = copy.deepcopy(table)
    # print(table)
    # print(copyTable)
    #Step2 : Reorder the table column according to the encryption key
    # encryptionKey = {3: 1, 1: 2, 4: 3, 5: 4, 2: 5}
    for row in range(len(copyTable)):
        for j in range(len(copyTable[row])):
            copyTable[row][j] = table[row][encryptionKey[j]]

    # print(copyTable)
    print(f"Table after reordering according to the encryption key: {copyTable}")
    # Step3 : Now we read the table column by column
    cipher = ''
    for cols in range(len(copyTable[0])): #cols = 0 to 4
        for rows in range(len(copyTable)): #rows = 0 to 2
            cipher += copyTable[rows][cols]

    print(cipher)
    return cipher, copyTable


def decryption(message, keyword, table):
    key = int(keyword) #Converting the numeric string into an integer
    # splitmessage = [message[i:i+key] for i in range(0, len(message), key)]
    # lenSplit = len(splitmessage)
    splitmessageforDecrypt = [message[i:i+len(table)] for i in range(0, len(message), len(table))]
    print(splitmessageforDecrypt)
    # print(splitmessage)
    #
    # table = [['z' for i in range(key)] for j in range(len(splitmessage))]
    columnTable = [[0 for i in range(key)] for j in range(math.ceil(len(message)/key))]

    #Step1: Entering the message characters in the table column by column.
    # for rows in range(len(columnTable)): #row = 0, 1, 2, 3
    #     for cols in range(len(columnTable[0])): #cols = 0, 1, 2, 3, 4
    #         columnTable[cols][rows] = table[rows][cols] #[1,0] = [0,1], [2,0] = [0,2]
    #                                                     #[1,0], [1,1],[1,2]
    #         pass
    # for rows in range(len(splitmessage)):
    #     i = rows
    #     j = 0
    #     for cols in range(key):
    #         if j < len(splitmessage[i]):
    #             table[rows][cols] = splitmessage[i][j]
    #             j = j + 1
    # print(f"Table after reading column by column : {columnTable}")
    # i = 0
    # j = 0
    for cols in range(key): #Key = 5, [0,1,2,3,4]
        i = cols
        j = 0
        for rows in range(len(table)): #len(table) = 4 [0,1,2,3]
            # if j < len(splitmessage[i]):
                columnTable[j][i] = splitmessageforDecrypt[i][j]
                j = j + 1
    print(f"Table after reading column by column : {columnTable}")
    #Step2 : Reorder the matrix according to the decryption key
    #Take the copy of the table
    copyTable = copy.deepcopy(columnTable)
    # print(table)
    # print(copyTable)
    #Step2 : Reorder the table column according to the decryption key
    # encryptionKey = {3: 1, 1: 2, 4: 3, 5: 4, 2: 5}
    for row in range(len(copyTable)):
        for j in range(len(copyTable[row])):
            copyTable[row][j] = columnTable[row][decryptionKey[j]]

    print(f"Table after reordering according to the decryption key: {copyTable}")

    #Step 3: read the table row by row
    decryptedPlainText = ''
    for rows in range(len(copyTable)):
        for cols in range(len(copyTable[rows])):
            decryptedPlainText += copyTable[rows][cols]

    print(decryptedPlainText)
    return decryptedPlainText, copyTable
def main():
    message = input("Enter the plaintext: ")
    key = input("Enter the key(group size or column size): ")

    middileText, table = encryption(message, key)
    print(f"The encrypted middletext is: {middileText.upper()}")
    cipherText, table = encryption(middileText, key)
    # cipherText = encryption("I am Shafi.", "5")
    print(f"The encrypted ciphertext is: {cipherText.upper()}")
    middileText, table = decryption(cipherText, key, table)
    print(f"The decrypted middletext is: {middileText.lower()}")
    plaintext, table = decryption(middileText, key, table)
    print(f"The decrypted plaintext is: {plaintext.lower()}")



main()















Elgamal

import math, random
from sympy import primitive_root,randprime

def keyGeneration():
    #Step1: Select a large prime number p
    p = int(input(f"Enter a large prime number p: "))
    #Step2: Select d to be a member of the group G = <Zp*, *> such that 1 <= d <= p-2
    d = random.randint(1, p-2)
    # d = 3
    print(f"Private Key: {d}")
    #Step3: Select e1 to be the primitive root in the group G = <Zp*, *>
    # e1 = 2
    # The number for which you want to find the primitive root
    # p = randprime(124, 10 ** 3)
    e1 = primitive_root(p)
    print(f"One of the Primitive root of {p} is: {e1}")

    #Step4: e2 = e1^d mod p
    e2 = mod_power(e1, d, p)
    print(f"Public Key: {e1},{e2},{p}")
    return e1, e2, p, d

def mod_power(a, n, m):
    r = 1  #r is the output value or return value
    # y = a % m , here y is y0, since it will be done anyway in line 84, we omit this line And since y is not used any further, we can replace yi with a
    while n > 0:
        if n & 1 == 1:  #Here, we grab every bit b0, b1, b1,..,bt and move them to the LSB position, when bitwise ANDED with ...0001, All the bits except the LSB bit is 0ed,
            # only the LSB bit is preserved.
            #Then we right shift the n by 1 (line 85) so that the next bit position b1 comes to the LSB position, in this way we traverse the binary digits in reverse order(from b0 to bt), we do this until all the bit values becomes 0 in which case bi becomes 0 and we break out of the while loop
            r = (r * a) % m #Same as product of yi(mod m) if the corresponding bit value is 1
        a = (a * a) % m #same as yi + 1 = (yi)^2 the recurrence relation we established on slide, it needs to be done for every bit position no matter what(bi can be 0 or 1)
        n >>= 1 #Every time, I advance the bit position further
    return r



def encrypt(e1, e2, p, msg):
    #Step1: Select a random integer r in the group G = <Zp*, *>
    r = random.randint(1, p-1)
    # r = 4
    #c1 = e1^r mod p
    c1 = mod_power(e1, r, p)
    #c2 = (msg * e2^r) mod p = (msg mod p) * (e2^r mod p)
    c2 = (msg % p) * mod_power(e2, r, p)
    return c1, c2


def decrypt(d, p, c1, c2):
    #msg = (c2*(c1^d)^(-1)) mod p
    res = pow(c1 ** d, -1, p)
    P = (c2 * res) % p
    return P


def main():
    msg = int(input(f"Enter the message(in numerical value): "))
    print(f'Original message:{msg}')
    # This routine creates the public and private key at the receiver side
    e1, e2, p, d = keyGeneration()
    c1, c2 = encrypt(e1,e2,p,msg)
    print(f'Encrypted message: ({c1},{c2})')
    decryptedPlainText = decrypt(d, p, c1, c2)
    print(f'Decrypted message: {decryptedPlainText}')

if __name__ == '__main__':
    main()














